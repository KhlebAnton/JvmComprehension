
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
/*
1. создание локальной переменной внутри метода, находящейся в области видимости метода main
создается ссылка в фрейме main; в heap`е хранится значение
2. создание ссылочной переменной, находящейся в области видимости метода main
 создается ссылка в фрейме main; в heap`е хранится ссылка на данный объект
3. создание локальной переменной внутри метода, находящейся в области видимости метода main
 создается ссылка в фрейме main; в heap`е хранится ссылка на данный объект
4. вызов метода с тремя параметрами
 создается новый фрейм при вызове локального метода; в heap`е хранится ссылка на данные объекты: Object o, int i, Integer ii
5. создание локальной переменной внутри метода, находящейся в области видимости метода printAll
 создается ссылка в фрейме printAll; в heap`е хранится значение
6. вывод в консоль
 создается новый фрейм при вызове sout
7. вывод в консоль
 создается новый фрейм при вызове sout

1. ClassLoader
         Прогрузка Loading:
         - происходит процесс прогрузки класса JvmComprehension классом Loading
         - загрузчик Bootstrap ClassLoader его не найдет, так как JvmComprehension не является jar`ом
         - загрузчик Platform ClassLoader его не найдет, так как JvmComprehension наш общий загрузчик
         - так как JvmComprehension наш самописный код, то его загрузит с помощью Application ClassLoader
         Связывание Linking:
         - происходит проверка байткода (Verify)
         - следующая стадия Prepare: резолвим поля, медоты класса JvmComprehension
         - выстраиваем ссылки взаимодействия между классами (Resolve)

2. Области памяти (стэк (и его фреймы), хип, метаспейс)
            - существуют два фрейма(main, printAll), которые хранят соответствующие ссылки на объекты
            - так же два фрейма, предназначенные для вывода, соответствующих значений в консоль
                * System.out.println("finished")
                * System.out.println(o.toString() + i + ii)
            - фрейм, созданный вызовом метода o.toString()
            - в heap`е зарезервировалось место для хранения таких объектов, как: i, o, ii, uselessVar
            - метаспейс хранится информация о системных классах и о классе JvmComprehension

3. Сборщик мусора
            - переменная uselessVar в локальном методе printAll не используется, т.к при помощи
            графа достижимости uselessVar является мусором
            - объекты i, o, ii будут дольше жить, так как непосредственно зайдествованы в другом локальном методе
  */